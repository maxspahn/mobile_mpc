#!/usr/bin/env python

import rospy
import numpy as np
import tf
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64, Float64MultiArray
from sensor_msgs.msg import JointState
from mm_msgs.msg import ActiveInferenceGoal


class mpcErrorPublisher(object):
    def __init__(self):
        rospy.init_node("errorComputationMPC")
        self.rate = rospy.Rate(10)
        self.pub = rospy.Publisher('/mpcError', Float64, queue_size=10)
        self.subGoal_ = rospy.Subscriber('/curAIgoal', ActiveInferenceGoal, self.goal_cb)
        self.transformer = tf.TransformListener()
        self.subJointPosition = rospy.Subscriber(
            "/mmrobot/joint_states", JointState, self.jointState_cb
        )
        self.curState = np.zeros(10)
        self.motionType = 0
        self.targetConfig = np.zeros(10)

    def getBaseState(self):
        while (True):
            try:
                (pos, quat) = self.transformer.lookupTransform("/map", "/chassis_link", rospy.Time(0))
                break
            except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
                continue
        self.curState[0] = pos[0]
        self.curState[1] = pos[1]
        euler = tf.transformations.euler_from_quaternion(quat)
        self.curState[2] = euler[2]

    def jointState_cb(self, jointStates):
        self.curState[3:10] = np.array(jointStates.position[3:10])

    def goal_cb(self, goalData):
        rospy.loginfo(goalData)
        self.targetConfig = goalData.targetConfig.data
        self.motionType = goalData.motionType

    def computeError(self):
        self.getBaseState()
        rospy.loginfo(self.motionType)
        if self.motionType == 1:
            prefix = "fineMotion"
        elif self.motionType == 2:
            prefix = "armMotion"
        else:
            prefix = "navigation"
        errorWeights = rospy.get_param(prefix + "/errorWeights");
        accum = 0.0
        for i in range(2):
            e = errorWeights[0] * (self.curState[i] - self.targetConfig[i]) ** 2
            accum = accum + e
        e = errorWeights[1] * (self.curState[2] - self.targetConfig[2]) ** 2
        accum = accum + e
        for i in range(3, 10):
            e = errorWeights[2] * (self.curState[i] - self.targetConfig[i]) ** 2
            accum = accum + e
        return np.sqrt(accum)

    def run(self):
        while not rospy.is_shutdown():
            self.curError = self.computeError()
            self.pub.publish(self.curError)
            self.rate.sleep()


if __name__ == "__main__":
    myMPCErrorPublisher = mpcErrorPublisher()
    myMPCErrorPublisher.run()
