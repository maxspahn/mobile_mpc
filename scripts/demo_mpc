#! /usr/bin/env python

import rospy

import actionlib

import tf
import time
import numpy as np
import mobile_mpc.msg
from mobile_mpc import solve_MPC_mm
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64, Float64MultiArray
from sensor_msgs.msg import JointState


class MPCNode(object):
    def __init__(self, name):
        rospy.init_node("mpc")
        self.pubLeftWheel = rospy.Publisher(
            "/mmrobot/left_wheel/command", Float64, queue_size=10
        )
        self.pubRightWheel = rospy.Publisher(
            "/mmrobot/right_wheel/command", Float64, queue_size=10
        )
        self.pubArm = rospy.Publisher(
            "/mmrobot/multijoint_command", Float64MultiArray, queue_size=10
        )
        self.tfListener = tf.TransformListener()
        self.subJointPosition = rospy.Subscriber(
            "/mmrobot/joint_states", JointState, self.jointState_cb
        )
        self.curU = np.zeros(9)
        self.curState = np.ones(10) * 100000
        self.goal = np.zeros(10)

        self.time_horizon = 20
        self.nbVar = 20
        self.slackVar = np.zeros(1)
        self.PARAMS = {}
        self.dt = 0.25
        self.rate = rospy.Rate(1 / self.dt)
        self.problemSetup()
        self.rate.sleep()
        time.sleep(1)

    def run(self, goal):
        # helper variables
        self.goal = goal
        error = 10000

        while True:
            oldError = error
            error = self.computeError()
            rospy.loginfo("Current Error : %1.5f", error)
            diff = np.abs(self.goal - self.curState)
            maxDiff = np.max(diff)
            argMaxDiff = np.argmax(diff)
            print(maxDiff)
            rospy.loginfo("Maximal Error at %i with %1.5f", argMaxDiff, maxDiff)
            rospy.loginfo(
                "Desired %1.5f but actual %1.5f",
                self.goal[argMaxDiff],
                self.curState[argMaxDiff],
            )
            if error < 0.15:
                success = True
                break
            exitFlag = self.singleMPCStep()
        print("Finishing Execution")
        self.publishVelocities(np.zeros(2), np.zeros(7))
        return True

    def odom_cb(self, odometry):
        curPos = np.array(
            [odometry.pose.pose.position.x, odometry.pose.pose.position.y]
        )
        curQuat = odometry.pose.pose.orientation
        quaternion = (curQuat.x, curQuat.y, curQuat.z, curQuat.w)
        euler = tf.transformations.euler_from_quaternion(quaternion)
        curOri = np.array([euler[2]])
        self.curState[0:3] = np.concatenate((curPos, curOri))

    def jointState_cb(self, jointStates):
        self.curState[3:10] = np.array(jointStates.position[3:10])
        self.curU[2:9] = np.array(jointStates.velocity[3:10])
        self.curU[0:2] = np.array(jointStates.velocity[10:12])

    def computeError(self):
        return np.linalg.norm(
            self.curState[0:3] - self.goal[0:3]
        ) + 0.5 * np.linalg.norm(self.curState[3:10] - self.goal[3:10])

    def problemSetup(self):
        wheel_radius = 0.08
        wheel_distance = 0.544
        self.setup = np.array([self.dt, wheel_radius, wheel_distance])
        self.x0 = np.zeros(self.nbVar * self.time_horizon)
        self.xinit = np.zeros(20)
        # q, x, o, slack, u, qdot,
        #self.weights = np.array([10.0, 1000.0, 1.0, 100000000.0, 1.0, 100.0])
        self.weights = np.array([1, 100, 5, 1000000000, 0.5, 10])
        self.safetyMargin = np.array([0.05])
        nbObstacles = 5
        nbPlanes = 8
        self.obstacles = np.ones(nbObstacles * 4) * -100
        plane1 = np.array([-2.5, -2, 0, 2.5, -2, 0, -2.5, -2, 2])
        plane2 = np.array([-2.5, -3, 0, 2.5, -3, 0, -2.5, -3, 2])
        plane3 = np.array([4, -2, 0, 4, -7, 0, 4, -2, 2])
        plane4 = np.array([5, -2, 0, 5, -7, 0, 5, -2, 2])
        plane5 = np.array([-2, -5.5, 0, 0, -5.5, 0, -2, -5.5, 0.7])
        plane6 = np.array([-2, -7.5, 0, 0, -7.5, 0, -2, -7.5, 0.7])
        plane7 = np.array([-2, -5.5, 0, -2, -7.5, 0, -2, -5.5, 0.7])
        plane8 = np.array([0, -5.5, 0, 0, -7.5, 0, 0, -5.5, 0.7])
        self.planes = np.concatenate(
            (plane1, plane2, plane3, plane4, plane5, plane6, plane7, plane8)
        )

    def getState(self):
        (tBase, rotBase) = self.tfListener.lookupTransform(
            "odom", "base_link", rospy.Time(0)
        )
        curPos = np.array(tBase)
        euler = tf.transformations.euler_from_quaternion(rotBase)
        curOri = np.array([euler[2]])
        self.curState[0:3] = np.concatenate((curPos[0:2], curOri))

        """
        (to0, r) = self.tfListener.lookupTransform('odom', 'sphere_0', rospy.Time(0))
        (to1, r) = self.tfListener.lookupTransform('odom', 'sphere_1', rospy.Time(0))
        (to2, r) = self.tfListener.lookupTransform('odom', 'sphere_2', rospy.Time(0))
        (to3, r) = self.tfListener.lookupTransform('odom', 'sphere_3', rospy.Time(0))
        (to4, r) = self.tfListener.lookupTransform('odom', 'sphere_4', rospy.Time(0))
        to0.append(1.0)
        to1.append(1.0)
        to2.append(1.0)
        to3.append(2.0)
        to4.append(0.5)
        self.obstacles[0:4] = to0
        self.obstacles[4:8] = to1
        self.obstacles[8:12] = to2
        self.obstacles[12:16] = to3
        self.obstacles[16:20] = to4
        """

    def solve(self):
        self.getState()
        self.xinit = np.concatenate((self.curState, self.slackVar, self.curU))
        x0 = np.concatenate((self.curState, self.slackVar, self.curU))
        self.x0 = np.tile(x0, self.time_horizon)
        singleParam = np.concatenate(
            (
                self.setup,
                self.goal,
                self.weights,
                self.safetyMargin,
                self.planes,
                self.obstacles,
            )
        )
        params = np.tile(singleParam, self.time_horizon)
        print(self.weights)
        self.PARAMS["xinit"] = self.xinit
        self.PARAMS["x0"] = self.x0
        self.PARAMS["all_parameters"] = params
        [output, exitFlag, info] = solve_MPC_mm.solve_MPC_mm(self.PARAMS)
        rospy.loginfo("Iterations : %i", info.it)
        rospy.loginfo("Exitflag %i", exitFlag)
        return [output, exitFlag]

    def publishVelocities(self, u_wheels, u_arm):
        u_right = Float64(u_wheels[1])
        u_left = Float64(u_wheels[0])
        u_joints = Float64MultiArray()
        u_joints.data = []
        for i in range(7):
            u_joints.data.insert(i, u_arm[i])
        self.pubRightWheel.publish(u_right)
        self.pubLeftWheel.publish(u_left)
        self.pubArm.publish(u_joints)

    def singleMPCStep(self):
        now = rospy.get_rostime()
        rospy.loginfo("After time %i %i", now.secs, now.nsecs)
        # Read states and input at time k
        [output, exitFlag] = self.solve()
        rospy.loginfo("Slack Variable : %1.5f", output["x02"][10])
        # Take solution for time k+1
        x_exp = output["x02"][0:10]
        u_opt_wheels = output["x02"][11:13]
        u_opt_arm = output["x02"][13:20]
        self.slackVar[0] = output["x02"][10]
        newx0 = []
        for i in range(2, self.time_horizon + 1):
            key = "x" + str(i).zfill(2)
            newx0 = np.concatenate((newx0, output[key]))
            if i == self.time_horizon:
                newx0 = np.concatenate((newx0, output[key]))

        self.x0 = np.array(newx0)
        self.rate.sleep()
        now = rospy.get_rostime()
        """
        rospy.loginfo("time for k+1 %i %i", now.secs, now.nsecs)
        rospy.loginfo("state at time k+1 %1.5f %1.5f %1.5f", self.curState[0], self.curState[1], self.curState[2])
        rospy.loginfo("predicted state  at time k+1 %1.5f %1.5f %1.5f", x_exp[0], x_exp[1], x_exp[2])
        rospy.loginfo("predicted u_opt_wheels  at time k+1 %1.5f %1.5f", u_opt_wheels[0], u_opt_wheels[1])
        """
        rospy.loginfo("u_opt %1.5f and %1.5f", u_opt_wheels[0], u_opt_wheels[1])
        self.publishVelocities(u_opt_wheels, u_opt_arm)
        return exitFlag


if __name__ == "__main__":
    myNode = MPCNode("mpc")
    while not rospy.is_shutdown():
        goal = np.array([0, -10, -1.57, 0, -1, -0.25, -1.5, 0.5, 2.1, 0.0])
        goal = np.array([-4, 0, -1.57, 0, -1, -0.25, -1.5, 0.5, 2.1, 0.0])
        # pre grasping pose
        goal = np.array([-1, -5, 0, 0, -1, -0.25, -1.5, 0.5, 2.1, 0.0])
        # grasping pose
        goal = np.array([-1, -5.0, 0, -1.57, 0.8, -0.0, -1.3, 0.0, 2.1, 0.75])
        goal = np.array([-4, -2, -1.57, 0, -1, -0.25, -1.5, 0.5, 2.1, 0.0])
        goal = np.array([0, 0, -1.57, 0, -1, -0.25, -1.5, 0.5, 2.1, 0.0])
        if myNode.run(goal):
            break
