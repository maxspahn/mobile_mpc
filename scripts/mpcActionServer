#! /usr/bin/env python

import rospy

import actionlib

import tf
import time
import numpy as np
import mobile_mpc.msg
from mobile_mpc import solve_MPC_mm
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64, Float64MultiArray
from sensor_msgs.msg import JointState


class MPCAction(object):
    # create messages that are used to publish feedback/result
    _feedback = mobile_mpc.msg.mpcFeedback()
    _result = mobile_mpc.msg.mpcResult()

    def __init__(self, name):
        self.initializeTopicCommunication()
        self.initializeMPCSettings()
        self.initializeActionServer(name)

        self.maxError = 0.4
        self.errorWeights = np.array([1, 0.5, 0.5])

    def initializeActionServer(self, name):
        self._action_name = name
        self._as = actionlib.SimpleActionServer(
            self._action_name,
            mobile_mpc.msg.mpcAction,
            execute_cb=self.execute_cb,
            auto_start=False,
        )
        self._as.start()

    def initializeMPCSettings(self):
        self.curU = np.zeros(9)
        self.curState = np.ones(10) * 100000
        self.goal = np.zeros(10)

        self.time_horizon = 20
        self.nbVar = 20
        self.slackVar = np.zeros(1)
        self.PARAMS = {}
        self.dt = 0.25
        self.rate = rospy.Rate(1 / self.dt)
        self.problemSetup()
        self.rate.sleep()

    def initializeTopicCommunication(self):
        self.pubLeftWheel = rospy.Publisher(
            "/mmrobot/left_wheel/command", Float64, queue_size=10
        )
        self.pubRightWheel = rospy.Publisher(
            "/mmrobot/right_wheel/command", Float64, queue_size=10
        )
        self.pubArm = rospy.Publisher(
            "/mmrobot/multijoint_command", Float64MultiArray, queue_size=10
        )
        self.tfListener = tf.TransformListener()
        self.subJointPosition = rospy.Subscriber(
            "/mmrobot/joint_states", JointState, self.jointState_cb
        )

    def execute_cb(self, goal):
        # Obsolete as weights are setted using the goal message
        self.resetWeights()

        self._feedback.errorFlag = 0

        rospy.loginfo("Executing MPC Action")

        self.goal = goal.goal.data
        self.errorWeights = goal.errorWeights.data
        self.maxError = goal.maxError.data
        self.weights = np.array(goal.mpcWeights.data)

        # start timer
        startTime = rospy.get_rostime()

        error = 10000000
        while True:
            oldError = error
            error = self.computeError()
            rospy.loginfo("Current error: %1.5f", error)
            """
            if error > 1.5 * oldError:
                success = False
                break
            if error < 1:
                self.weights = self.weights * 1.0
            """
            if error < self.maxError:
                success = True
                break
            exitFlag = self.singleMPCStep()
            if self._as.is_preempt_requested():
                rospy.loginfo("%s: Preempted" % self._action_name)
                self._as.set_preempted()
                sucess = False
                break
        # Stop timer
        endTime = rospy.get_rostime()
        deltaT = endTime - startTime
        rospy.loginfo("Finishing Execution after %i sec %i ms", deltaT.secs, deltaT.nsecs)
        self.publishVelocities(np.zeros(2), np.zeros(7))

        # start executing the action
        # check that preempt has not been requested by the client
        # publish the feedback
        self._as.publish_feedback(self._feedback)

        self._result.finalState = Float64MultiArray()
        if success:
            self._result.success = True
            self._result.finalState.data = self.curState
            rospy.loginfo("%s: Succeeded" % self._action_name)
            self._as.set_succeeded(self._result)
        else:
            self._result.success = False
            rospy.loginfo("%s: Failed" % self._action_name)
            self._as.set_succeeded(self._result)

    def jointState_cb(self, jointStates):
        self.curState[3:10] = np.array(jointStates.position[3:10])
        self.curU[2:9] = np.array(jointStates.velocity[3:10])
        self.curU[0:2] = np.array(jointStates.velocity[10:12])

    def computeError(self):
        return (
            self.errorWeights[0] * np.linalg.norm(self.curState[0:2] - self.goal[0:2])
            + self.errorWeights[1] * np.linalg.norm(self.curState[2] - self.goal[2])
            + self.errorWeights[1]
            * np.linalg.norm(self.curState[2:10] - self.goal[2:10])
        )

    def problemSetup(self):
        wheel_radius = 0.08
        wheel_distance = 0.544
        self.setup = np.array([self.dt, wheel_radius, wheel_distance])
        self.x0 = np.zeros(self.nbVar * self.time_horizon)
        self.xinit = np.zeros(20)
        # q, x, o, slack, u, qdot,
        # self.weights = np.array([10.0, 1000.0, 1.0, 100000000.0, 1.0, 100.0])
        self.weights = np.array([1, 100, 5, 1000000000, 0.5, 10])
        self.safetyMargin = np.array([0.02])
        nbObstacles = 5
        nbPlanes = 8
        self.obstacles = np.ones(nbObstacles * 4) * -100
        plane1 = np.array([-2.5, -2, 0, 2.5, -2, 0, -2.5, -2, 2])
        plane2 = np.array([-2.5, -3, 0, 2.5, -3, 0, -2.5, -3, 2])
        plane3 = np.array([4, -2, 0, 4, -7, 0, 4, -2, 2])
        plane4 = np.array([5, -2, 0, 5, -7, 0, 5, -2, 2])
        plane5 = np.array([-2, -5.5, 0, 0, -5.5, 0, -2, -5.5, 0.7])
        plane6 = np.array([-2, -7.5, 0, 0, -7.5, 0, -2, -7.5, 0.7])
        plane7 = np.array([-2, -5.5, 0, -2, -7.5, 0, -2, -5.5, 0.7])
        plane8 = np.array([0, -5.5, 0, 0, -7.5, 0, 0, -5.5, 0.7])
        self.planes = np.concatenate(
            (plane1, plane2, plane3, plane4, plane5, plane6, plane7, plane8)
        )

    def resetWeights(self):
        self.weights = np.array([10.0, 10.0, 10.0, 10000000.0, 10.0, 100.0, 1.0, 1.0])

    def getState(self):
        (tBase, rotBase) = self.tfListener.lookupTransform(
            "odom", "base_link", rospy.Time(0)
        )
        curPos = np.array(tBase)
        euler = tf.transformations.euler_from_quaternion(rotBase)
        curOri = np.array([euler[2]])
        self.curState[0:3] = np.concatenate((curPos[0:2], curOri))

    def getObstacles(self):
        try:
            (to0, r) = self.tfListener.lookupTransform(
                "/odom", "sphere_0", rospy.Time(0)
            )
            (to1, r) = self.tfListener.lookupTransform(
                "/odom", "sphere_1", rospy.Time(0)
            )
            (to2, r) = self.tfListener.lookupTransform(
                "/odom", "sphere_2", rospy.Time(0)
            )
            (to3, r) = self.tfListener.lookupTransform(
                "/odom", "sphere_3", rospy.Time(0)
            )
            (to4, r) = self.tfListener.lookupTransform(
                "/odom", "sphere_4", rospy.Time(0)
            )

            to0.append(1.0)
            to1.append(1.0)
            to2.append(1.0)
            to3.append(1.0)
            to4.append(1.0)
            self.obstacles[0:4] = to0
            self.obstacles[4:8] = to1
            self.obstacles[8:12] = to2
            self.obstacles[12:16] = to3
            self.obstacles[16:20] = to4

        except (
            tf.LookupException,
            tf.ConnectivityException,
            tf.ExtrapolationException,
        ):
            print("Error with tf listener")

    def solve(self):
        self.getState()
        self.xinit = np.concatenate((self.curState, self.slackVar, self.curU))
        x0 = np.concatenate((self.curState, self.slackVar, self.curU))
        self.x0 = np.tile(x0, self.time_horizon)
        singleParam = np.concatenate(
            (
                self.setup,
                self.goal,
                self.weights,
                self.safetyMargin,
                self.planes,
                self.obstacles,
            )
        )
        params = np.tile(singleParam, self.time_horizon)
        self.PARAMS["xinit"] = self.xinit
        self.PARAMS["x0"] = self.x0
        self.PARAMS["all_parameters"] = params
        [output, exitFlag, info] = solve_MPC_mm.solve_MPC_mm(self.PARAMS)
        if info.it <= 1:
            exitflag = -111
        rospy.loginfo("Exitflag : %d", exitFlag)
        return [output, exitFlag]

    def publishVelocities(self, u_wheels, u_arm):
        u_left = Float64(u_wheels[0])
        u_right = Float64(u_wheels[1])
        u_joints = Float64MultiArray()
        u_joints.data = []
        for i in range(7):
            u_joints.data.insert(i, u_arm[i])
        self.pubRightWheel.publish(u_right)
        self.pubLeftWheel.publish(u_left)
        self.pubArm.publish(u_joints)

    def singleMPCStep(self):
        [output, exitFlag] = self.solve()
        x_exp = output["x02"][0:10]
        u_opt_wheels = output["x02"][11:13]
        u_opt_arm = output["x02"][13:20]
        self.slackVar[0] = output["x02"][10]
        newx0 = []
        for i in range(2, self.time_horizon + 1):
            key = "x" + str(i).zfill(2)
            newx0 = np.concatenate((newx0, output[key]))
            if i == self.time_horizon:
                newx0 = np.concatenate((newx0, output[key]))

        self.x0 = np.array(newx0)
        self.rate.sleep()
        if exitFlag == -111:
            rospy.loginfo("MPC aborted...publish zero velocity")
            self.publishVelocities(np.zeros(2), np.zeros(7))
        else:
            self.publishVelocities(u_opt_wheels, u_opt_arm)
        return exitFlag


if __name__ == "__main__":
    rospy.init_node("mpc_server")
    server = MPCAction(rospy.get_name())
    rospy.spin()
