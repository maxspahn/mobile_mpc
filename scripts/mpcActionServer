#! /usr/bin/env python

import rospy

import actionlib

import tf
import time
import numpy as np
import mobile_mpc.msg
from mobile_mpc import solve_MPC_mm
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64, Float64MultiArray
from sensor_msgs.msg import JointState


class MPCAction(object):
    # create messages that are used to publish feedback/result
    _feedback = mobile_mpc.msg.mpcFeedback()
    _result = mobile_mpc.msg.mpcResult()

    def __init__(self, name):
        self.pubLeftWheel = rospy.Publisher(
            "/mmrobot/left_wheel/command", Float64, queue_size=10
        )
        self.pubRightWheel = rospy.Publisher(
            "/mmrobot/right_wheel/command", Float64, queue_size=10
        )
        self.pubArm = rospy.Publisher(
            "/mmrobot/multijoint_command", Float64MultiArray, queue_size=10
        )
        self.tfListener = tf.TransformListener()
        self.subJointPosition = rospy.Subscriber(
            "/mmrobot/joint_states", JointState, self.jointState_cb
        )

        self.curU = np.zeros(9)
        self.curState = np.zeros(10)
        self.goal = np.zeros(10)

        self.time_horizon = 20
        self.nbVar = 20
        self.slackVar = np.zeros(1)
        self.PARAMS = {}
        self.dt = 0.4
        self.rate = rospy.Rate(1 / self.dt)
        self.rate.sleep()
        self.problemSetup()
        self.maxError = 0.4
        self.errorWeights = np.array([1.0, 1.0, 0.5])

        self._action_name = name
        self._as = actionlib.SimpleActionServer(
            self._action_name,
            mobile_mpc.msg.mpcAction,
            execute_cb=self.execute_cb,
            auto_start=False,
        )
        self._as.start()

    def execute_cb(self, goal):
        # helper variables
        success = True
        self.problemSetup()

        # append the seeds for the fibonacci sequence
        self._feedback.errorFlag = 0

        # publish info to the console for the user
        rospy.loginfo("Executing MPC Action")

        self.goal = goal.goal.data
        self.errorWeights = goal.errorWeights.data
        self.maxError = goal.maxError.data
        self.weights = np.array(goal.mpcWeights.data)
        print(self.weights)

        error = 100
        while True:
            oldError = error
            error = self.computeError()
            rospy.loginfo("Current error: %1.5f", error)
            print((self.curState - self.goal))
            if error > 1.5 * oldError:
                success = False
                break
            if error < 1:
                self.weights = self.weights * 1.1
            if error < self.maxError:
                success = True
                break
            exitFlag = self.singleMPCStep()
            if self._as.is_preempt_requested():
                rospy.loginfo("%s: Preempted" % self._action_name)
                self._as.set_preempted()
                sucess = False
                break
        print("Finishing Execution")
        self.publishVelocities(np.zeros(2), np.zeros(7))

        # start executing the action
        # check that preempt has not been requested by the client
        # publish the feedback
        self._as.publish_feedback(self._feedback)

        self._result.finalState = Float64MultiArray()
        if success:
            self._result.success = True
            self._result.finalState.data = self.curState
            rospy.loginfo("%s: Succeeded" % self._action_name)
            self._as.set_succeeded(self._result)
        else:
            self._result.success = False
            rospy.loginfo("%s: Failed" % self._action_name)
            self._as.set_succeeded(self._result)

    def jointState_cb(self, jointStates):
        self.curState[3:10] = np.array(jointStates.position[3:10])
        self.curU[2:9] = np.array(jointStates.velocity[3:10])
        self.curU[0:2] = np.array(jointStates.velocity[10:12])

    def computeError(self):
        return (
            self.errorWeights[0] * np.linalg.norm(self.curState[0:2] - self.goal[0:2])
            + self.errorWeights[1] * np.linalg.norm(self.curState[2] - self.goal[2])
            + self.errorWeights[2]
            * np.linalg.norm(self.curState[3:10] - self.goal[3:10])
        )

    def problemSetup(self):
        wheel_radius = 0.08
        wheel_distance = 0.544
        self.setup = np.array([self.dt, wheel_radius, wheel_distance])
        self.x0 = np.zeros(self.nbVar * self.time_horizon)
        self.xinit = np.zeros(20)
        # q, x, o, slack, u, qdot,
        self.weights = np.array([10.0, 10.0, 10.0, 10000000.0, 10.0, 100.0])
        nbObstacles = 100
        self.obstacles = np.ones(nbObstacles * 4) * -100
        self.getObstacles()

    def getState(self):
        try:
            (tBase, rotBase) = self.tfListener.lookupTransform(
                "/odom", "base_link", rospy.Time(0)
            )
            curPos = np.array(tBase)
            euler = tf.transformations.euler_from_quaternion(rotBase)
            curOri = np.array([euler[2]])
            self.curState[0:3] = np.concatenate((curPos[0:2], curOri))
        except (
            tf.LookupException,
            tf.ConnectivityException,
            tf.ExtrapolationException,
        ):
            print("Error with tf listener")

    def getObstacles(self):
        for i in range(84):
            frameName = "sphere_" + str(i)
            (to, r) = self.tfListener.lookupTransform("odom", frameName ,rospy.Time(0))
            to.append(0.2)
            self.obstacles[i * 4: i * 4 + 4] = to

    def solve(self):
        self.getState()
        x0 = np.concatenate((self.curState, self.slackVar, self.curU))
        self.xinit = x0
        self.x0 = np.tile(x0, self.time_horizon)
        singleParam = np.concatenate(
            (self.setup, self.goal, self.weights, self.obstacles)
        )
        params = np.tile(singleParam, self.time_horizon)
        self.PARAMS["xinit"] = self.xinit
        self.PARAMS["x0"] = self.x0
        self.PARAMS["all_parameters"] = params
        [output, exitFlag, info] = solve_MPC_mm.solve_MPC_mm(self.PARAMS)
        return [output, exitFlag]

    def publishVelocities(self, u_wheels, u_arm):
        u_left = Float64(u_wheels[0])
        u_right = Float64(u_wheels[1])
        u_joints = Float64MultiArray()
        u_joints.data = []
        for i in range(7):
            u_joints.data.insert(i, u_arm[i])
        self.pubRightWheel.publish(u_right)
        self.pubLeftWheel.publish(u_left)
        self.pubArm.publish(u_joints)

    def singleMPCStep(self):
        # Read states and input at time k
        [output, exitFlag] = self.solve()
        # Take solution for time k+1
        x_exp = output["x02"][0:12]
        u_opt_wheels = output["x02"][11:13]
        u_opt_arm = output["x02"][13:20]
        print(u_opt_wheels)
        self.slackVar[0] = output["x02"][10]
        newx0 = []
        for i in range(2, self.time_horizon + 1):
            key = "x" + str(i).zfill(2)
            newx0 = np.concatenate((newx0, output[key]))
            if i == self.time_horizon:
                newx0 = np.concatenate((newx0, output[key]))

        self.x0 = np.array(newx0)
        self.rate.sleep()
        now = rospy.get_rostime()
        self.publishVelocities(u_opt_wheels, u_opt_arm)
        return exitFlag


if __name__ == "__main__":
    rospy.init_node("mpc")
    server = MPCAction(rospy.get_name())
    rospy.spin()
