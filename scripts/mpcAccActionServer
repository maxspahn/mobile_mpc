#! /usr/bin/env python

import rospy

import actionlib

import tf
import time
import numpy as np
import mobile_mpc.msg
from mobile_mpc import solve_MPC_mm
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64, Float64MultiArray
from sensor_msgs.msg import JointState


class MPCAction(object):
    # create messages that are used to publish feedback/result
    _feedback = mobile_mpc.msg.mpcFeedback()
    _result = mobile_mpc.msg.mpcResult()

    def __init__(self, name):
        self.pubLeftWheel = rospy.Publisher(
            "/mmrobot/left_wheel/command", Float64, queue_size=10
        )
        self.pubRightWheel = rospy.Publisher(
            "/mmrobot/right_wheel/command", Float64, queue_size=10
        )
        self.pubArm = rospy.Publisher(
            "/mmrobot/multijoint_command", Float64MultiArray, queue_size=10
        )
        self.tfListener = tf.TransformListener()
        self.subJointPosition = rospy.Subscriber(
            "/mmrobot/joint_states", JointState, self.jointState_cb
        )

        self.curU = np.zeros(9)
        self.curState = np.zeros(19)
        self.goal = np.zeros(10)


        self.time_horizon = 20
        self.nbVar = 29
        self.slackVar = np.zeros(1)
        self.PARAMS = {}
        self.dt = 0.4
        self.rate = rospy.Rate(1/self.dt)
        self.problemSetup()
        self.maxError = 0.4
        self.errorWeights = np.array([1, 0.5])

        self._action_name = name
        self._as = actionlib.SimpleActionServer(
            self._action_name,
            mobile_mpc.msg.mpcAction,
            execute_cb=self.execute_cb,
            auto_start=False,
        )
        self._as.start()

    def execute_cb(self, goal):
        # helper variables
        success = True
        self.problemSetup()

        # append the seeds for the fibonacci sequence
        self._feedback.errorFlag = 0

        # publish info to the console for the user
        rospy.loginfo("Executing MPC Action")

        self.goal = goal.goal.data
        self.errorWeights = goal.errorWeights.data
        self.maxError = goal.maxError.data
        self.weights = np.array(goal.mpcWeights.data)

        error = 100
        while True:
            oldError = error
            error = self.computeError()
            rospy.loginfo("Current error: %1.5f", error)
            if error > 1.5 * oldError:
                success = False
                break
            if error < 1:
                self.weights = self.weights * 1.1
            if error < self.maxError:
                success = True
                break
            exitFlag = self.singleMPCStep()
            if self._as.is_preempt_requested():
                rospy.loginfo("%s: Preempted" % self._action_name)
                self._as.set_preempted()
                sucess = False
                break
        print("Finishing Execution")
        self.publishVelocities(np.zeros(2), np.zeros(7))

        # start executing the action
        # check that preempt has not been requested by the client
        # publish the feedback
        self._as.publish_feedback(self._feedback)

        self._result.finalState = Float64MultiArray()
        if success:
            self._result.success = True
            self._result.finalState.data = self.curState
            rospy.loginfo("%s: Succeeded" % self._action_name)
            self._as.set_succeeded(self._result)
        else:
            self._result.success = False
            rospy.loginfo("%s: Failed" % self._action_name)
            self._as.set_succeeded(self._result)

    def jointState_cb(self, jointStates):
        self.curState[5:12] = np.array(jointStates.position[3:10])
        self.curState[3:5] = np.array(jointStates.velocity[10:12])
        self.curState[12:19] = np.array(jointStates.velocity[3:10])

    def computeError(self):
        return self.errorWeights[0] *np.linalg.norm(
            self.curState[0:2] - self.goal[0:2]
        ) + self.errorWeights[1] * np.linalg.norm(self.curState[2:10] - self.goal[2:10])

    def problemSetup(self):
        wheel_radius = 0.08
        wheel_distance = 0.544
        self.setup = np.array([self.dt, wheel_radius, wheel_distance])
        self.x0 = np.zeros(self.nbVar * self.time_horizon)
        self.xinit = np.zeros(self.nbVar)
        # q, x, o, slack, u, qdot,
        self.weights = np.array([10.0, 10.0, 10.0, 10000000.0, 10.0, 100.0, 1.0, 1.0])
        nbObstacles = 5
        self.obstacles = np.ones(nbObstacles * 4) * -100

    def getObstacles(self):
        try:
            (tBase, rotBase) = self.tfListener.lookupTransform('/odom', 'base_link', rospy.Time(0))
            (to0, r) = self.tfListener.lookupTransform('/odom', 'sphere_0', rospy.Time(0))
            (to1, r) = self.tfListener.lookupTransform('/odom', 'sphere_1', rospy.Time(0))
            (to2, r) = self.tfListener.lookupTransform('/odom', 'sphere_2', rospy.Time(0))
            (to3, r) = self.tfListener.lookupTransform('/odom', 'sphere_3', rospy.Time(0))
            (to4, r) = self.tfListener.lookupTransform('/odom', 'sphere_4', rospy.Time(0))
            curPos = np.array(tBase)
            euler = tf.transformations.euler_from_quaternion(rotBase)
            curOri = np.array([euler[2]])
            self.curState[0:3] = np.concatenate((curPos[0:2], curOri))

            to0.append(1.0)
            to1.append(1.0)
            to2.append(1.0)
            to3.append(1.0)
            to4.append(1.0)
            self.obstacles[0:4] = to0
            self.obstacles[4:8] = to1
            self.obstacles[8:12] = to2
            self.obstacles[12:16] = to3
            self.obstacles[16:20] = to4

        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            print("Error with tf listener")


    def solve(self):
        self.getState()
        x0 = np.concatenate((self.curState, self.slackVar, self.curU))
        self.xinit = x0
        self.x0 = np.tile(x0, self.time_horizon)
        singleParam = np.concatenate((self.setup, self.goal, self.weights, self.obstacles))
        params = np.tile(singleParam, self.time_horizon)
        self.PARAMS["xinit"] = self.xinit
        self.PARAMS["x0"] = self.x0
        self.PARAMS["all_parameters"] = params
        [output, exitFlag, info] = solve_MPC_mm.solve_MPC_mm(self.PARAMS)
        return [output, exitFlag]

    def publishVelocities(self, u_wheels, u_arm):
        u_left = Float64(u_wheels[0])
        u_right = Float64(u_wheels[1])
        u_joints = Float64MultiArray()
        u_joints.data = []
        for i in range(7):
            u_joints.data.insert(i, u_arm[i])
        self.pubRightWheel.publish(u_right)
        self.pubLeftWheel.publish(u_left)
        self.pubArm.publish(u_joints)

    def singleMPCStep(self):
        # Read states and input at time k
        [output, exitFlag] = self.solve()
        # Take solution for time k+1
        u_opt_wheels = output["x02"][3:5]
        u_opt_arm = output["x02"][12:19]
        self.slackVar[0] = output["x02"][19]
        newx0 = []
        for i in range(2, self.time_horizon + 1):
            key = "x" + str(i).zfill(2)
            print(output[key][12:19])
            newx0 = np.concatenate((newx0, output[key]))
            if i == self.time_horizon :
                newx0 = np.concatenate((newx0, output[key]))

        self.x0 = np.array(newx0)
        self.rate.sleep()
        now = rospy.get_rostime()
        self.curU = output["x02"][20:29]
        self.publishVelocities(u_opt_wheels, u_opt_arm)
        return exitFlag

if __name__ == "__main__":
    rospy.init_node("mpc")
    server = MPCAction(rospy.get_name())
    rospy.spin()
