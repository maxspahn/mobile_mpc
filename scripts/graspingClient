#! /usr/bin/env python

import rospy

# Brings in the SimpleActionClient
import actionlib
import numpy as np

from std_msgs.msg import Float64MultiArray, Float64
from mm_msgs.srv import MMIk
from geometry_msgs.msg import Pose, PoseStamped

# Brings in the messages used by the fibonacci action, including the
# goal message and the result message.
import mobile_mpc.msg


def mpc_client():
    mpcClient = actionlib.SimpleActionClient("mpc_server", mobile_mpc.msg.mpcAction)

    rospy.wait_for_service('ik_computation')

    computeIk = rospy.ServiceProxy('ik_computation', MMIk)
    p = Pose()
    p.position.x = 0.3
    p.position.y = 0.1
    p.position.z = 1.2
    # Pointing in negative x direction
    p.orientation.x = 0.0
    p.orientation.y = -0.7071
    p.orientation.z = 0.0000
    p.orientation.w = 0.7071
    # Pointing in positiv x direction
    p.orientation.x = 0.0
    p.orientation.y = 0.7071
    p.orientation.z = 0.0000
    p.orientation.w = 0.7071
    # Pointing in negatif y direction
    p.orientation.x = 0.0
    p.orientation.y = 0.0000
    p.orientation.z = 0.7071
    p.orientation.w = 0.7071
    # Pointing in negatif z direction
    p.orientation.x = 0.0
    p.orientation.y = 1.0000
    p.orientation.z = 0.0000
    p.orientation.w = 0.0000
    pS = PoseStamped()
    pS.pose = p
    pS.header.frame_id = "odom"
    resp1 = computeIk(pS)
    print(resp1)

    mpcClient.wait_for_server()

    prefix = "armMotion"
    safetyMargin = rospy.get_param(prefix + "/safetyMargin")
    myMaxError = rospy.get_param(prefix + "/maxError")
    errorWeights = rospy.get_param(prefix + "/errorWeights")
    myMPCWeights = rospy.get_param(prefix + "/weights")

    a = np.array(resp1.config.data)
    mpcGoalConfig = np.concatenate((np.zeros(3), np.array(resp1.config.data)))

    actionGoal = mobile_mpc.msg.mpcGoal(
        goal=Float64MultiArray(data=mpcGoalConfig),
        errorWeights=Float64MultiArray(data=errorWeights),
        maxError=Float64(data=myMaxError),
        mpcWeights=Float64MultiArray(data=myMPCWeights),
        safetyMargin=Float64(data=safetyMargin)
    )

    # Sends the goal to the action server.
    mpcClient.send_goal(actionGoal)

    # Waits for the server to finish performing the action.
    mpcClient.wait_for_result()

    # Prints out the result of executing the action
    result =mpcClient.get_result()
    print("Result:", result.success)
    print("Final State : ", result.finalState.data)
    return mpcClient.get_result()  # A FibonacciResult


if __name__ == "__main__":
    try:
        # Initializes a rospy node so that the SimpleActionClient can
        # publish and subscribe over ROS.
        rospy.init_node("mpc_client_node")
        result = mpc_client()
    except rospy.ROSInterruptException:
        print("program interrupted before completion")
